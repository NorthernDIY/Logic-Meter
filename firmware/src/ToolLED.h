/* 
 * File:   ToolLED.h
 * Author: Bob
 *
 * Created on June 2, 2020, 5:50 PM
 */

#ifndef TOOLLED_H
#define	TOOLLED_H

#include "SPI.h"
#include "CVRef.h"
#include "Tool.h"
#include "LEDTestPane.h"

// Programmable Gain Amplifier
class MCP6S21
{
public:
    MCP6S21()
    {
        _opAmp.Initialize(true, SPI_FrequencyGet() / (2 * OP_AMP_SPI_FREQ) - 1, false, 16);
        _opAmp.SetMode(0, 0);
        _opAmp.UseSPISelect(true);
        _opAmp.Enable();
    }
    
    ~MCP6S21() {Shutdown(); _opAmp.Disable();}
    
    void Enable() {_opAmp.Enable();}
    void Disable() {_opAmp.Disable();}
    
    uint8_t LowValue() const {return 0;}
    uint8_t HighValue() const {return 7;}
    uint8_t Gain(uint8_t value) const 
    {
        static const uint8_t gains[] = {1, 2, 4, 5, 8, 10, 16, 32};
        return gains[value];
    }
    
    void Set(uint8_t value)
    {
        while (!_opAmp.TXReady()) {}
        _opAmp.TXData(0x4000 + value);
    }
    void Shutdown()
    {
        while (!_opAmp.TXReady()) {}
        _opAmp.TXData(0x2000);
    }
    
    bool IsBusy() {return !_opAmp.TXReady();}
    
private:
    // SPI and UART peripherals use the same clock. This is kludge because we
    // have UART3_FrequencyGet being generated by Harmony, so we're using it
    // top get the SPI's clock frequency
    uint32_t SPI_FrequencyGet() {return UART3_FrequencyGet();}

    static const uint32_t OP_AMP_SPI_FREQ = 1000000; // datasheet says max. is 10 MHz
    
    CSPI2 _opAmp;
};

class ToolLED : public Tool 
{
public:
    static Tool *Factory() {return new ToolLED;}
    
    ToolLED();
    virtual ~ToolLED();
    
    virtual void OnIdle();
    
    virtual void Update();
    
    void IncreaseCurrent();
    void DecreaseCurrent();
    
private:
    ToolLED(const ToolLED& orig);
    
    LEDTestPane *GetPane() {return (LEDTestPane *) Tool::GetPane();}
    
    enum {WaitingForLED, TestingLED, ModifyingCurrent} _state;
    
    // Voltage reference level, in tenths of a volt
    static const int vRef = 3300;
    static const int maxADCReading = 0xfff;
    static const int resistorValue = 22;
    
    CVRef _cvref;
    MCP6S21 _opAmp;
    
    struct Sample
    {
        uint8_t opAmpValue, cvrRange, cvrValue;
        
        uint32_t opAmpReading;
        uint32_t ledAnodeReading;
        bool operator==(const Sample &s2) const
        {
            return Compare(*this, s2) == 0;
        }
        bool operator<(const Sample &s2) const
        {
            return Compare(*this, s2) < 0;
        }
        
        static int Compare(const Sample &s1, const Sample &s2)
        {
            int diff = s1.ledAnodeReading - s2.ledAnodeReading;
            if (diff == 0)
                diff = s1.opAmpReading - s2.opAmpReading;
            return diff;
        }
    };
    std::vector<Sample> _samples;
    std::vector<LEDTestPane::XY> _mVfuA;
    size_t _currentSampleIndex;
    
    Sample ReadADCs(uint8_t opAmpValue, uint8_t cvrRange, uint8_t cvrValue);
    LEDTestPane::XY TomVfuA(const Sample &sample);
};

#endif	/* TOOLLED_H */

