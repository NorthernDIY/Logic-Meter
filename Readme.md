[TOC]



# Logic Meter

## Introduction

Logic Meter is a piece of electronic test equipment meant to make certain functions of a logic analyzer as easy to use as a multimeter. You can see a demo at https://youtu.be/55UjsmX5F90

It looks like a multimeter: it's handheld, battery operated, has a display, has a knob for selecting the measurement you want to make, and has a set of buttons for navigating a menu to set options (e.g. setting the baud rate for the UART "measurement").

But unlike a multimeter, the logic meter's probes are for digital signals only (max. 5 volts) and the "measurements" are the sorts of things you'd do to test a microcontroller-based system.

The currently implemented measurements are:

- UART In: connect two of the logic meter's probes to ground and a UART signal, and the logic meter will display the UART data on the screen.
- UART Out: send canned data out one of the probes in UART format. The logic meter has the ASCII set built in as one choice of canned data. Files can be copied over to the logic meter via USB and used as alternative canned data.
- SPI In: connect three or four of the probes to  GND, MOSI, CLK, and (optionally) SS, and the logic meter will display the SPI data on the screen.
- GPS Simulator: the logic meter will send GPS data (NMEA sentences) out one of its probe wires. There is not GPS in the logic meter, so this is simulated data. You can set the time, longitude, and latitude. The logic meter draws a map of the Earth on the display and you can move a cursor to indicate the location you want to simulate.
- Servo: the logic meter will send a 50Hz square wave out one of its probe wires. The user can change the duty cycle. This signal can be used to control a servo motor.
- PWM: the logic meter will send a square wave out one of its probe wires. The user can change both the frequency and the duty cycle.
- ~~LED Test: put an LED in the LED socket and the logic meter will graph the forward current versus forward voltage on the display. You can then adjust the amount of current going through the LED and see how bright it is. This helps you decide how much current you want flowing through it and calculate a current-limiting resistor accordingly.~~
- Logic Analyzer: the logic meter will sample values on the three inputs and display traces on the display. Triggers can be set for rising, falling, or either edge, on any of the inputs.
- Utility: Enables the logic meter's USB interface. Also could allow (in the future) for setting various configuration options or controlling the logic meter remotely.
- The rotary switch used in the current design has one unused position, to add additional features.

This repository contains the hardware design and the firmware. This Readme file contains helpful information in understanding them.

It is my hope that someone will take this design, or at least this idea of a logic meter, and turn it into a mass-manufactured product. If you do this, I only ask that you contact me and let me know. I would like to be able to buy a professionally made version of this. You can contact me through my GitHub account, galacticstudios, or my website, GalacticStudios.org.

## Hardware

This repository includes the schematic and layout files in the Hardware folder. They were generated by [DipTrace](https://diptrace.com/), a CAD package available at no cost for non-commercial projects or at relatively modest cost for commercial projects.

The logic meter is based on a Microchip PIC32MZ2048EFH064 microcontroller. It uses a color LCD module with an SPI interface and a 10-position rotary switch.

The PIC32 is programmable with an In-Circuit Serial Programmer from Microchip. The ICSP connector, however, is not Microchip's. It is the [Tag-Connect TC2030-MCP](https://www.tag-connect.com/product/tc2030-mcp-6-pin-cable-with-rj12-modular-plug-for-microchip-icd). Its advantage is that it doesn't require a header to be soldered onto the PCB.

The rotary switch does not have a common pin. Instead, it connects adjacent pins to each other, so in position 1 it connects pin 1 to 2; in position 2 it connects pin 2 to 3, and so on until the last position, where it connects pin 10 to 1. See the comment in the schematic for a description of how we use this switch.

There is a 0.1" header with 4 pins for the probes. One pin is ground. The other 3 are connected to 5V tolerant pins on the PIC32. The PIC32 has a "Peripheral Pin Select" (PPS) feature where different peripherals (UART, SPI, etc.) can have their inputs and outputs routed to different pins. There are four PPS groups, so each of the three probes is connected to four pins on the PIC32. This ensures that every probe pin can be routed to nearly any peripheral on the PIC32. The current design does not make use of all that flexibility, but it's there.

~~A separate 0.1" header with two pins is for the LED Test. The PIC32 selects different voltages to drive the LED by setting its Comparator Voltage Reference to one of 16 levels. That voltage goes into a Programable Gain Amplifier chip that can source up to 25mA. (The CVref + PGA are essentially forming a low resolution D/A converter) The PGA's output goes through a 22 ohm, 1% resistor and then to the LED Test header, where the user can insert an LED for testing. The PIC32 uses its A/D converters to measure voltage on either end of the resistor. The difference between them is the voltage drop across the resistor, and we can calculate the forward current from that. The voltage on the low end of the resistor (also the LED's anode) is the forward voltage of the LED.~~

The logic meter is powered by a LiPo battery. There is a USB port with circuitry for charging the battery. The USB port data lines are connected the the PIC32.

There are six buttons. Five are for selecting menu items on the screen; the sixth is meant as a Help button.

### Suggested Improvements

- Replace the rotary switch with a multimeter-style selection switch, which uses traces on the board and contacts on the knobs.
- Replace the display with a parallel LCD, preferably with a flex ribbon cable instead of being on a (relatively) expensive PCB of its own. Use PIC32's Port E, since that's what the Parallel Master Port uses.
- Replace the buttons with a silicone keypad.
- ~~Replace the CVref/PGA circuitry used for the LED Test with a single D/A converter. The challenge is finding one that can output high enough current.~~
- Do the probe inputs need some sort of additional protection from high voltages?
- Connect the battery (after the on/off switch) to a voltage divider and an A/D pin, so we can sense the charge on the battery.
- The charging LED needs to stick out of the enclosure more.
- Change the USB mini-B jack to a USB C.
- We need a nice wire harness for the probes. I like what the LA104 handheld logic analyzer (sold under various brand names) ships with.

## Mechanical

The PCB is sized to fit in a Takachi LC145-N enclosure.

### Suggested improvements

- Design a nice, custom, injection-molded enclosure.
- Whether you replace the rotary switch with a multimeter-like selection switch or not, the knob needs a better feel to it than it currently has: it can wiggle a bit. Multimeter knobs have detents and spring-loaded beads that give them a more precise feel.
- Replace the buttons with a silicone keypad.

## Software

The software uses Microchip's freely available toolchain:

- MPLAB X IDE. The code here was developed with version 5.35 but newer versions are almost certainly compatible.
- XC32 C/C++ compiler 2.40. Newer versions are probably compatible.
- Microchip Harmony 3.x. Each module has its own version. When you try to open the Microchip Harmony Configurator (MHC), it will tell you which versions it wants.

The Harmony code is in C. My code is in C++. If you re-generate the Harmony code from MHC, you'll see I've made some changes directly to the Harmony-generated files. These are generally to make the .h files compile under C++, although there are also a couple of places where I'm fixing bugs in the Harmony code.

For my code, look in the "Application" logical folder in the MPLAB X Projects pane. It contains subfolders: 

- Framework: for the most part, this is the main application loop.
- Panes: Aria, the Microchip GUI library I'm using, has Panels that are containers for other widgets. Each logic meter function has a panel associated with it. The panes are C++ objects that control the widgets inside the Aria panel, so there's typically one pane per panel.
- Peripherals: these are object wrappers around the PIC32 peripherals. You'll see a few different approaches here: classes that interact directly with the peripheral registers, classes that interact with the Harmony wrapper around the registers, and macros that expand into class definitions. The reason there's no single approach is that I've been experimenting. I'd love to come up with an object-oriented peripheral library, but I haven't figured out the best way to do it. Maybe there is no good way, and that's why all the microcontroller manufacturers come out with code generation tools that have "smarts" that just can't be encapsulated in macros, classes, and C++ templates.
- Tools: each function on the logic meter (i.e. each setting of the rotary switch) has a corresponding tool.
- Widgets: Aria has a bunch of standard GUI widgets, but here we have some wrappers for those widgets that add application-specific functionality.

### Suggested Improvements

- The PIC32 has Peripheral Module Disable (PMD) registers that allow you to shut down a peripheral, thereby saving power. Each tool should turn on the peripherals it needs and turn them off when it's done.
- Add an I2C tool. Unfortunately, I don't think we can use the built-in I2C peripheral. We want to listen, like a slave does, but we don't want to send ACK and NACK bits - we just want to watch for them. So we can't be a slave. Fortunately, Harmony has an I2C bit-banging library. We can start with that and alter the code.
- Add a logic probe tool. Have it draw an LED on the display and beep the speaker to indicate high, low, and pulsed signals. Do we need extra circuitry to detect high impedance?
- Other tools to consider: frequency counter; manual pulse generator (i.e. push a button and it sends a pulse); UART, SPI, and I2C transmit tools (maybe load a data file over USB, then have the logic meter transmit it on command); signal generator (is an analog signal from 0-5V useful, or would we need additional hardware to generate a negative voltage?).
- Add USB features. The current code implements a USB COM device, and that could be used for sending commands to the logic meter and getting data back. See [Dangerous Prototype's Bus Pirate](http://dangerousprototypes.com/docs/Bus_Pirate) for an idea of what could be done.
- We should also have a bootloader that allows firmware upgrades through the USB.
- Enhance the UART tool. Currently, it connects to one signal and displays the data. But UARTs, of course, have two signals, RX and TX. We could use the RX line of another PIC32 UART to capture both sides of a UART conversation. We'd have to display each side in a different color or something.
- Enhance the SPI tool too. Instead of using one of the probe pins for Slave Select, we could use it for MISO.
- Also in SPI, select 8, 16, or 32 bits.
- Add settings, like brightness control, display time out, firmware upgrade, I don't know what else.
- Add more help text. Right now, it only says which probe pins to wire up. Should it say more?
- Show the battery level.
- Detect the battery charging, based on Vbus.

## Manufacturing

Need a test harness that exercises all the features.

