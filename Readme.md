[TOC]



# Logic Meter

## Introduction

Logic Meter is a piece of electronic test equipment meant to make certain functions of a logic analyzer as easy to use as a multimeter.

It looks like a multimeter: it's handheld, battery operated, has a display, has a knob for selecting the measurement you want to make, and has a set of buttons for navigating a menu to set options (e.g. setting the baud rate for the UART "measurement").

But unlike a multimeter, the logic meter's probes are for digital signals only (max. 5 volts) and the "measurements" are the sorts of things you'd do to test a microcontroller-based system.

The currently implemented measurements are:

- UART: connect two of the logic meter's probes to ground and a UART signal, and the logic meter will display the UART data on the screen.
- SPI: connect three or four of the probes to  GND, MOSI, CLK, and (optionally) SS, and the logic meter will display the SPI data on the screen.
- GPS Simulator: the logic meter will send GPS data (NMEA sentences) out one of its probe wires. There is not GPS in the logic meter, so this is simulated data. You can set the time, longitude, and latitude. The logic meter draws a map of the Earth on the display and you can move a cursor to indicate the location you want to simulate.
- Servo: the logic meter will send a 50Hz square wave out one of its probe wires. The user can change the duty cycle. This signal can be used to control a servo motor.
- PWM: the logic meter will send a square wave out one of its probe wires. The user can change both the frequency and the duty cycle.
- LED Test: put an LED in the LED socket and the logic meter will graph the forward current versus forward voltage on the display. You can then adjust the amount of current going through the LED and see how bright it is. This helps you decide how much current you want flowing through it and calculate a current-limiting resistor accordingly.
- The rotary switch used in the current design has three more unused positions, to add three more features.

This repository contains the hardware design and the firmware. This Readme file contains helpful information in understanding them.

It is my hope that someone will take this design, or at least this idea of a logic meter, and turn it into a mass-manufactured product. If you do this, I only ask that you send me a free unit. You don't have to, but it would be a nice way to say "thank you". You can contact me through my GitHub account, galacticstudios, or my website, GalacticStudios.org.

## Hardware

This repository includes the schematic and layout files in the Hardware folder. They were generated by [DipTrace](https://diptrace.com/), a CAD package available at no cost for non-commercial projects or at relatively modest cost for commercial projects.

The logic meter is based on a Microchip PIC32MZ2048EFH064 microcontroller. It uses a 2.2" color LCD module with an SPI interface ([HiLetgo 2.2 Inch ILI9341 SPI TFT LCD Display, 240x320](https://smile.amazon.com/dp/B01CZL6QIQ/ref=cm_sw_em_r_mt_dp_3HtvFb380AB5K)) and a 10-position rotary switch.

The PIC32 is programmable with an In-Circuit Serial Programmer from Microchip. The ICSP connector, however, is not Microchip's. It is the [Tag-Connect TC2030-MCP](https://www.tag-connect.com/product/tc2030-mcp-6-pin-cable-with-rj12-modular-plug-for-microchip-icd). Its advantage is that it doesn't require a header to be soldered onto the PCB.

The rotary switch does not have a common pin. Instead, it connects adjacent pins to each other, so in position 1 it connects pin 1 to 2; in position 2 it connects pin 2 to 3, and so on until the last position, where it connects pin 10 to 1. See the comment in the schematic for a description of how we use this switch.

There is a 0.1" header with 4 pins for the probes. One pin is ground. The other 3 are connected to 5V tolerant pins on the PIC32. The PIC32 has a "Peripheral Pin Select" (PPS) feature where different peripherals (UART, SPI, etc.) can have their inputs and outputs routed to different pins. There are four PPS groups, so each of the three probes is connected to four pins on the PIC32. This ensures that every probe pin can be routed to nearly any peripheral on the PIC32. The current design does not make use of all that flexibility, but it's there.

A separate 0.1" header with two pins is for the LED Test. The PIC32 selects different voltages to drive the LED by setting its Comparator Voltage Reference to one of 16 levels. That voltage goes into a Programable Gain Amplifier chip that can source up to 25mA. (The CVref + PGA are essentially forming a low resolution D/A converter) The PGA's output goes through a 22 ohm, 1% resistor and then to the LED Test header, where the user can insert an LED for testing. The PIC32 uses its A/D converters to measure voltage on either end of the resistor. The difference between them is the voltage drop across the resistor, and we can calculate the forward current from that. The voltage on the low end of the resistor (also the LED's anode) is the forward voltage of the LED.

The logic meter is powered by a LiPo battery. There is a USB port with circuitry for charging the battery. The USB port data lines are connected the the PIC32.

There are six buttons. Five are for selecting menu items on the screen; the sixth is meant as a Help button.

The PCB is sized to fit in a Bud Industries PT-11668 enclosure. There are marks on the PCB for the centers of the buttons and small holes in the PCB indicating the four corners of the LCD and the center of the rotary switch. I use these marks and holes to help me drill holes in the front on the enclosure.

In the Mechanical directory, there are OpenSCAD models for 3D printing a battery holder that fits inside the PT-11668 case and includes the right size spacers for mounter the PCB.

### Suggested Improvements

- Replace the rotary switch with a multimeter-style selection switch, which uses traces on the board and contacts on the knobs.
- Replace the display with a parallel LCD, preferably with a flex ribbon cable instead of being on a (relatively) expensive PCB of its own.
- Replace the CVref/PGA circuitry used for the LED Test with a single D/A converter. The challenge is finding one that can output high enough current.
- Design a nice custom enclosure.
- Do the probe inputs need some sort of additional protection from high voltages?
- Do something about the piezo speaker. It's currently on the back side of the LCD. That means it can't be soldered in after the LCD has been installed. Either move the speaker or replace it with an SMT speaker.
- The charging LED needs to stick out of the enclosure more.
- We need a nice wire harness for the probes. I like what the LA104 handheld logic analyzer (sold under various brand names) ships with.

## Software

The software uses Microchip's freely available toolchain:

- MPLAB X IDE. The code here was developed with version 5.35 but newer versions are almost certainly compatible.
- XC32 C/C++ compiler 2.40. Newer versions are probably compatible.
- Microchip Harmony 3.x. Each module has its own version. When you try to open the Microchip Harmony Configurator (MHC), it will tell you which versions it wants.

The Harmony code is in C. My code is in C++. If you re-generate the Harmony code from MHC, you'll see I've made some changes directly to the Harmony-generated files. These are generally to make the .h files compile under C++, although there are also a couple of places where I'm fixing bugs in the Harmony code.

For my code, look in the "Application" logical folder in the MPLAB X Projects pane. It contains subfolders: 

- Framework: for the most part, this is the main application loop.
- Panes: Aria, the Microchip GUI library I'm using, has Panels that are containers for other widgets. Each logic meter function has a panel associated with it. The panes are C++ objects that control the widgets inside the Aria panel, so there's typically one pane per panel.
- Peripherals: these are object wrappers around the PIC32 peripherals. You'll see a few different approaches here: classes that interact directly with the peripheral registers, classes that interact with the Harmony wrapper around the registers, and macros that expand into class definitions. The reason there's no single approach is that I've been experimenting. I'd love to come up with an object-oriented peripheral library, but I haven't figured out the best way to do it. Maybe there is no good way, and that's why all the microcontroller manufacturers come out with code generation tools that have "smarts" that just can't be encapsulated in macros, classes, and C++ templates.
- Tools: each function on the logic meter (i.e. each setting of the rotary switch) has a corresponding tool.
- Widgets: Aria has a bunch of standard GUI widgets, but here we have some wrappers for those widgets that add application-specific functionality.

### Suggested Improvements

- The PIC32 has Peripheral Module Disable (PMD) registers that allow you to shut down a peripheral, thereby saving power. Each tool should turn on the peripherals it needs and turn them off when it's done.
- Add an I2C tool.
- Add a logic analyzer tool. The PIC32 has a very flexible DMA system to help here. Have a timer for the sample rate. Have it trigger a read from Port D into a memory buffer - that will capture all three probe inputs. Turn DMA channel 1's Auto-Enable on, so when the buffer fills up, the DMA re-starts at the beginning of the buffer. So now you have DMA channel 1 filling a buffer for capturing the signals leading up to the trigger event.
  For the trigger, either set up an Input Capture peripheral on the desired trigger signal or set up a DMA pattern detect. The trigger should stop DMA channel 1 and start DMA channel 2. DMA channels 2 through 8 should be chained together so that when one fills its buffer, it starts the next. So you'll end up with 64K samples before the trigger event and 7 x 64K = 448K samples after the event.
- Add a logic probe tool. Have it draw an LED on the display and beep the speaker to indicate high, low, and pulsed signals. Do we need extra circuitry to detect high impedance?
- Other tools to consider: frequency counter; manual pulse generator (i.e. push a button and it sends a pulse); UART, SPI, and I2C transmit tools (maybe load a data file over USB, then have the logic meter transmit it on command); signal generator (is an analog signal from 0-5V useful, or would we need additional hardware to generate a negative voltage?).
- Add USB features. The current code implements a USB COM device, and that could be used for sending commands to the logic meter and getting data back. See [Dangerous Prototype's Bus Pirate](http://dangerousprototypes.com/docs/Bus_Pirate) for an idea of what could be done. (The Bus Pirate code is open source, hint hint wink wink.)
- We should also have a bootloader that allows firmware upgrades through the USB.
- Enhance the UART tool. Currently, it connects to one signal and displays the data. But UARTs, of course, have two signals, RX and TX. We could use the RX line of another PIC32 UART to capture both sides of a UART conversation. We'd have to display each side in a different color or something.
- Enhance the SPI tool too. Instead of using one of the probe pins for Slave Select, we could use it for MISO.
- In the UART, SPI, and I2C tool, make the display scrollable.
- Add settings, like brightness control, display time out, firmware upgrade, I don't know what else.
- Add more help text. Right now, it only says which probe pins to wire up. Should it say more?